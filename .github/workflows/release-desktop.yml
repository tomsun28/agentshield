name: Release Desktop

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v0.1.0)'
        required: true
        type: string
  push:
    tags:
      - 'v*'

permissions:
  contents: write

concurrency:
  group: release-desktop-${{ github.ref_name }}
  cancel-in-progress: true

env:
  APP_NAME: AgentShield

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: macos-latest
            target: aarch64-apple-darwin
            os: darwin
            arch: aarch64

    runs-on: ${{ matrix.platform }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10
          run_install: false

      - name: Install Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install Linux dependencies
        if: matrix.os == 'linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Install root dependencies
        run: pnpm install

      - name: Install desktop dependencies
        working-directory: desktop
        run: pnpm install

      - name: Prepare Tauri signing key
        shell: bash
        env:
          TAURI_KEY_SECRET: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
        run: |
          if [ -z "$TAURI_KEY_SECRET" ]; then
            echo "::warning::TAURI_SIGNING_PRIVATE_KEY not set, updater signatures will be disabled"
            exit 0
          fi

          node << 'EOF'
          const fs = require('fs');
          
          let raw = process.env.TAURI_KEY_SECRET || '';
          if (!raw) {
            console.log('No key found in env');
            process.exit(0);
          }

          console.log('DEBUG: Raw secret length:', raw.length);
          console.log('DEBUG: Raw secret first 50 chars:', raw.substring(0, 50));

          // 1. Remove BOM and normalize line endings
          let content = raw.replace(/^\uFEFF/, '').replace(/\r\n/g, '\n').trim();
          console.log('DEBUG: Normalized content first 50 chars:', content.substring(0, 50));

          // 2. Decode if it looks like a base64-wrapped file (no spaces, pure base64)
          //    We check if the *entire* content is base64 and decodes to something containing "untrusted comment"
          if (!content.includes(' ') && !content.includes('\n') && content.length > 50) {
             try {
               const decoded = Buffer.from(content, 'base64').toString('utf8');
               if (decoded.includes('untrusted comment:')) {
                 console.log('Detected base64-encoded key file, decoded it.');
                 content = decoded.trim();
                 console.log('DEBUG: Decoded content first 50 chars:', content.substring(0, 50));
               }
             } catch (e) {
               console.log('DEBUG: Not base64 encoded file, proceeding as raw');
             }
          }

          // 3. Extract the key payload
          //    We look for the line that is NOT the comment.
          const lines = content.split('\n');
          let keyPayload = '';
          
          for (const line of lines) {
            const trimmed = line.trim();
            if (!trimmed) continue;
            if (trimmed.startsWith('untrusted comment:')) continue;
            
            // Assume this is the key
            keyPayload = trimmed;
            break; 
          }

          // If no key found yet, maybe the whole string is the key (no comment provided)
          if (!keyPayload && !content.startsWith('untrusted comment:')) {
            keyPayload = content.replace(/[\s\n]/g, '');
          }

          if (!keyPayload) {
             console.error('::error::Could not extract Tauri secret key payload');
             process.exit(1);
          }

          // 4. Sanitize payload (remove all spaces/newlines)
          keyPayload = keyPayload.replace(/[\s\r\n]/g, '');
          
          console.log('Key payload extracted (length: ' + keyPayload.length + ')');
          console.log('DEBUG: Key payload first 50 chars:', keyPayload.substring(0, 50));

          // 5. Reconstruct the full 2-line Minisign key format and write to file
          //    Tauri CLI expects a proper key file, not just the payload
          const keyFilePath = 'tauri_signing.key';
          const keyFileContent = `untrusted comment: minisign secret key\n${keyPayload}\n`;
          fs.writeFileSync(keyFilePath, keyFileContent);
          console.log('Reconstructed Minisign key file:', keyFilePath);
          
          // 6. Set TAURI_SIGNING_PRIVATE_KEY to the file path
          const githubEnv = process.env.GITHUB_ENV;
          if (githubEnv) {
             fs.appendFileSync(githubEnv, `TAURI_SIGNING_PRIVATE_KEY=${keyFilePath}\n`);
             console.log('Tauri signing key file path added to GITHUB_ENV');
             console.log('DEBUG: Wrote file path to GITHUB_ENV');
          } else {
             console.warn('GITHUB_ENV not defined, cannot export key');
          }
          EOF

      - name: Build CLI binary
        shell: bash
        run: |
          mkdir -p desktop/src-tauri/bin
          if [ "${{ matrix.os }}" = "windows" ]; then
            bun build --compile --target=bun-windows-x64 ./src/index.ts --outfile desktop/src-tauri/bin/shield.exe
          elif [ "${{ matrix.os }}" = "darwin" ] && [ "${{ matrix.arch }}" = "aarch64" ]; then
            bun build --compile --target=bun-darwin-arm64 ./src/index.ts --outfile desktop/src-tauri/bin/shield
          elif [ "${{ matrix.os }}" = "darwin" ] && [ "${{ matrix.arch }}" = "x86_64" ]; then
            bun build --compile --target=bun-darwin-x64 ./src/index.ts --outfile desktop/src-tauri/bin/shield
          else
            bun build --compile --target=bun-linux-x64 ./src/index.ts --outfile desktop/src-tauri/bin/shield
          fi

      - name: Build Tauri app
        working-directory: desktop
        env:
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: pnpm tauri build --target ${{ matrix.target }}

      - name: Package macOS artifacts
        if: matrix.os == 'darwin'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p release-assets
          VERSION="${{ github.event.inputs.version || github.ref_name }}"
          BUNDLE_DIR="desktop/src-tauri/target/${{ matrix.target }}/release/bundle/macos"

          # Find updater artifact (.tar.gz with signature)
          TAR_GZ=$(find "$BUNDLE_DIR" -maxdepth 1 -name "*.tar.gz" -type f 2>/dev/null | head -1 || true)
          if [ -n "$TAR_GZ" ]; then
            NEW_TAR_GZ="${APP_NAME}-${VERSION}-darwin-${{ matrix.arch }}.tar.gz"
            cp "$TAR_GZ" "release-assets/$NEW_TAR_GZ"
            [ -f "$TAR_GZ.sig" ] && cp "$TAR_GZ.sig" "release-assets/$NEW_TAR_GZ.sig"
            echo "Updater artifact: $NEW_TAR_GZ"
          fi

          # Create zip from .app for direct download
          APP_PATH=$(find "$BUNDLE_DIR" -maxdepth 1 -name "*.app" -type d 2>/dev/null | head -1 || true)
          if [ -n "$APP_PATH" ]; then
            APP_NAME_BASE=$(basename "$APP_PATH")
            NEW_ZIP="${APP_NAME}-${VERSION}-darwin-${{ matrix.arch }}.zip"
            cd "$(dirname "$APP_PATH")"
            ditto -c -k --sequesterRsrc --keepParent "$APP_NAME_BASE" "$NEW_ZIP"
            mv "$NEW_ZIP" "$GITHUB_WORKSPACE/release-assets/"
            echo "App zip: $NEW_ZIP"
          fi

          # Copy DMG if exists
          DMG=$(find "desktop/src-tauri/target/${{ matrix.target }}/release/bundle/dmg" -name "*.dmg" 2>/dev/null | head -1 || true)
          if [ -n "$DMG" ]; then
            cp "$DMG" "release-assets/${APP_NAME}-${VERSION}-darwin-${{ matrix.arch }}.dmg"
          fi

      - name: Package Linux artifacts
        if: matrix.os == 'linux'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p release-assets
          VERSION="${{ github.event.inputs.version || github.ref_name }}"

          # AppImage (updater artifact)
          APPIMAGE=$(find desktop/src-tauri/target/${{ matrix.target }}/release/bundle/appimage -name "*.AppImage" 2>/dev/null | head -1 || true)
          if [ -n "$APPIMAGE" ]; then
            NEW_APPIMAGE="${APP_NAME}-${VERSION}-linux-${{ matrix.arch }}.AppImage"
            cp "$APPIMAGE" "release-assets/$NEW_APPIMAGE"
            chmod +x "release-assets/$NEW_APPIMAGE"
            [ -f "$APPIMAGE.sig" ] && cp "$APPIMAGE.sig" "release-assets/$NEW_APPIMAGE.sig"
            echo "AppImage: $NEW_APPIMAGE"
          fi

          # Deb package
          DEB=$(find desktop/src-tauri/target/${{ matrix.target }}/release/bundle/deb -name "*.deb" 2>/dev/null | head -1 || true)
          if [ -n "$DEB" ]; then
            cp "$DEB" "release-assets/${APP_NAME}-${VERSION}-linux-${{ matrix.arch }}.deb"
          fi

          # RPM package
          RPM=$(find desktop/src-tauri/target/${{ matrix.target }}/release/bundle/rpm -name "*.rpm" 2>/dev/null | head -1 || true)
          if [ -n "$RPM" ]; then
            cp "$RPM" "release-assets/${APP_NAME}-${VERSION}-linux-${{ matrix.arch }}.rpm"
          fi

      - name: Package Windows artifacts
        if: matrix.os == 'windows'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p release-assets
          VERSION="${{ github.event.inputs.version || github.ref_name }}"

          # MSI installer (updater artifact)
          MSI=$(find desktop/src-tauri/target/${{ matrix.target }}/release/bundle/msi -name "*.msi" 2>/dev/null | head -1 || true)
          if [ -n "$MSI" ]; then
            NEW_MSI="${APP_NAME}-${VERSION}-windows-${{ matrix.arch }}.msi"
            cp "$MSI" "release-assets/$NEW_MSI"
            [ -f "$MSI.sig" ] && cp "$MSI.sig" "release-assets/$NEW_MSI.sig"
            echo "MSI installer: $NEW_MSI"
          fi

          # NSIS installer
          NSIS=$(find desktop/src-tauri/target/${{ matrix.target }}/release/bundle/nsis -name "*.exe" 2>/dev/null | head -1 || true)
          if [ -n "$NSIS" ]; then
            NEW_NSIS="${APP_NAME}-${VERSION}-windows-${{ matrix.arch }}-setup.exe"
            cp "$NSIS" "release-assets/$NEW_NSIS"
            [ -f "$NSIS.sig" ] && cp "$NSIS.sig" "release-assets/$NEW_NSIS.sig"
          fi

      - name: List release assets
        shell: bash
        run: ls -la release-assets/ || true

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: desktop-${{ matrix.os }}-${{ matrix.arch }}
          path: release-assets/*
          if-no-files-found: error

  release:
    name: Create Release
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          pattern: desktop-*
          merge-multiple: true

      - name: List downloaded artifacts
        run: ls -la artifacts/

      - name: Generate checksums
        run: |
          cd artifacts
          sha256sum * > checksums.txt
          cat checksums.txt

      - name: Generate latest.json for updater
        env:
          VERSION: ${{ github.event.inputs.version || github.ref_name }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          VERSION_NUM="${VERSION#v}"
          PUB_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          BASE_URL="https://github.com/$REPO/releases/download/$VERSION"

          # Initialize platform entries
          declare -A platforms

          cd artifacts
          for sig in *.sig; do
            [ -f "$sig" ] || continue
            base="${sig%.sig}"
            [ -f "$base" ] || continue

            url="$BASE_URL/$base"
            sig_content=$(cat "$sig")

            case "$base" in
              *darwin-aarch64.tar.gz)
                platforms["darwin-aarch64"]="{\"signature\": \"$sig_content\", \"url\": \"$url\"}" ;;
              *darwin-x86_64.tar.gz)
                platforms["darwin-x86_64"]="{\"signature\": \"$sig_content\", \"url\": \"$url\"}" ;;
              *linux-x86_64.AppImage)
                platforms["linux-x86_64"]="{\"signature\": \"$sig_content\", \"url\": \"$url\"}" ;;
              *windows-x86_64.msi)
                platforms["windows-x86_64"]="{\"signature\": \"$sig_content\", \"url\": \"$url\"}" ;;
            esac
          done
          cd ..

          # Build JSON
          cat > artifacts/latest.json << EOF
          {
            "version": "$VERSION_NUM",
            "notes": "Release $VERSION",
            "pub_date": "$PUB_DATE",
            "platforms": {
          EOF

          first=true
          for key in "${!platforms[@]}"; do
            if [ "$first" = true ]; then
              first=false
            else
              echo "," >> artifacts/latest.json
            fi
            echo -n "    \"$key\": ${platforms[$key]}" >> artifacts/latest.json
          done

          cat >> artifacts/latest.json << EOF

            }
          }
          EOF

          echo "Generated latest.json:"
          cat artifacts/latest.json

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.event.inputs.version || github.ref_name }}
          name: AgentShield Desktop ${{ github.event.inputs.version || github.ref_name }}
          draft: true
          body: |
            ## AgentShield Desktop ${{ github.event.inputs.version || github.ref_name }}

            Protect your AI-operated workspaces with automatic snapshots.

            ### Downloads

            - **macOS (Apple Silicon)**: `AgentShield-${{ github.event.inputs.version || github.ref_name }}-darwin-aarch64.zip`
            - **macOS (Intel)**: `AgentShield-${{ github.event.inputs.version || github.ref_name }}-darwin-x86_64.zip`
            - **Windows**: `AgentShield-${{ github.event.inputs.version || github.ref_name }}-windows-x86_64.msi`
            - **Linux**: `AgentShield-${{ github.event.inputs.version || github.ref_name }}-linux-x86_64.AppImage`

            ---
            > **macOS users**: If you see "app is damaged" error, run in terminal:
            > ```bash
            > xattr -cr "/Applications/AgentShield.app"
            > ```
          files: artifacts/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
